

# 穷举算法（暴力法）
穷举算法是一种最简单的一种算法，其依赖于计算机的强大计算能力来 **$\color{red}穷尽每一种可能的情况$** ，从而达到求解的目的。穷举算法效率不高，但适用于一些没有明显规律可循的场合。

二、穷举算法的基本思想就是从所有可能的情况中搜索正确的答案，其执行步骤如下:

(1)对于一种可能的情况，计算其结果。

(2)判断结果是否满足要求，如果不满足则进行执行第(1)步来搜索下一个可能的情况;如果满足要求，则表示寻找到一个正确的答案。

穷举的作用:

1.理论上，穷举可以解决可计算领域中的各种问题。尤其处在计算机计算速度非常高的今天，穷举的应用领域是非常广阔的。

2.在实际应用中，通常要解决的问题规模不大，用穷举设计的算法其运算速度是可以接受的。此时，设计一个更高效率的算法代价不值得。

3.穷举可作为某类问题时间性能的底限，用来衡量同样问题的更高效率的算法。

# 回溯算法
回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。
回溯算法的基本思想是：

**$\color{red}从一条路往前走，能进则进，不能进则退回来，换一条路再试$**

回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。

但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。

许多复杂的，规模较大的问题都可以使用回溯法，有 **$\color{red}“通用解题方法”$** 的美称。

回溯法简单来说就是按照深度优先的顺序，穷举所有可能性的算法，但是回溯算法比暴力穷举法更高明的地方就是回溯算法可以随时判断当前状态是否符合问题的条件。

# 分治算法
分治算法的基本思想是:

**$\color{red}将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。$**

求出子问题的解，就可得到原问题的解。即一种分目标完成程序算法，简单问题可用二分法完成。

分治法解题的一般步骤：
 * 分解，将要解决的问题划分成若干规模较小的同类问题；
 * 求解，当子问题划分得足够小时，用较简单的方法解决；
 * 合并，按原问题的要求，将子问题的解逐层合并构成原问题的解。

分治的简单应用是二分查找。

## 二分查找
利用二分查找可以递归的调用二分查找函数。

# 贪心算法（Greedy Algorithm) 简介

**$\color{red}只顾眼前利益，做出局部最优的选择，寄希望于这样的选择能导致全局最优解。$**

贪心算法（Greedy Algorithm，又称贪婪算法），指在对问题求解时，不从整体最优上加以考虑，而总是做出在当前看来是最好的选择。也就是说，所做出的是在某种意义上的局部最优解。

贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态只与它前面出现的状态有关，而独立于后面的状态。

贪心算法的两个性质是贪心选择性质和最优子结构性质：

* 贪心选择性质：
**指所求的问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来得到。贪心选择是采用从顶向下、以迭代的方法做出相继选择，每做一次贪心选择，就将所求问题简化为一个规模更小的子问题。**


* 最优子结构（optimal substructure）性质：
**如果原问题的最优解包含的子问题的最优解，而这些子问题可以独立求解，我们就称该问题具有最优子结构性质。其包含“全局最优解包含局部最优解”的思想。**

 贪心算法与动态规划的区别:
* 贪心算法的每一次操作都对结果产生直接影响，而动态规划则不是。
* 贪心算法对每个子问题的解决方案都做出选择，不能回退；动态规划则会根据以前的选择结果对当前进行选择，有回退功能。
* 动态规划主要运用于二维或三维问题，而贪心一般是一维问题。
实际上，贪心算法是一种特殊的动态规划，由于其具有贪心选择性质，保证了子问题只会被计算一次，不会被多次计算。

尽管贪心算法和动态规划都有最优子结构性质，我认为这个性质在两种算法中有着不太一样的含义：贪心的局部最优能达成全局最优，而动态规划的全局最优值中不一定全是局部最优，只是求解全局最优时要以局部最优作为基础。或者，我们可以认为，贪心算法通常都是自顶向下进行设计的，而动态规划则自顶向上。

**解题思路**

贪心算法的基本思路是从问题的某一个初始解出发一步一步地进行，根据某个优化测度，每一步都要确保能获得局部最优解。每一步只考虑一个数据，选取应该满足局部优化的条件。若下一个数据和部分最优解连在一起不再是可行解时，就不把该数据添加到部分解中，直到把所有数据枚举完，或者不能再添加算法停止。

# 动态规划
动态规划通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 动态规划常常适用于有重叠子问题和最优子结构性质的问题。
本质是： 
```
递归 + 记忆化。
```

也就是把f(n)转换成与f(n-1),...的关系, 例如斐波拉数列：
```
int Fibonacci(int n)
{
    if(n==1||n==2)
        return 1;
    else if(n<=0)
        return 0;
    else if(!memo[n])  //如果没有计算过，就计算一次并存下来
     memo[n]=Fibonacci(n-1)+Fibonacci(n-2);
    return memo[n];  //如果计算过了，直接返回之前记忆的计算结果
}
```



动态规划还是那常见的几个步骤:

* 确定状态(定义数组DP[k][i] //第i天最多j笔交易的情况下的最大利润)
  > 状态： 描述该问题的子问题的解，即根据子问题来定义状态。
  
* 找到转移方程(在数组中存值)  DP[k][i] = max(DP[k][i-1], DP[k-1][i-1] + prices[i])
  > 状态转移方程：状态和状态之间的关系式。大部分情况下，某个状态只与它前面出现的状态有关，而独立于后面的状态（无后效性）。
  
* 确定初始条件以及边界条件
* 计算结果

能使用动态规划思想解决的问题都有最优子结构性质和重叠子问题：

最优子结构（Optimal substructure）性质：如果问题的最优解所包含的子问题的解也是最优的，而这些子问题可以独立求解，我们就称该问题具有最优子结构性质。其包含“全局最优解包含局部最优解”的思想。

重叠子问题：指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。

# 算法思想

# 递推与递归（倒推）
递推是从第一个开始推导，一直推导到目标

递归是从目标反推，推导到起因

这两个只是一种思想

## 双指针
双指针是两个指针朝着左右方向移动（双指针分为同向双指针和异向双指针），直到他们有一个或是两个都满足某种条件。

进一步的双指针应用是滑动窗口。

### 滑动窗口
其实就是不断地调节子序列的起始位置和终止位置，从而得出要想的结果。
https://juejin.cn/post/7031180605450633230

### Pattern: Fast & Slow pointers, 快慢指针类型
这种模式，有一个非常出门的名字，叫龟兔赛跑。 咱们肯定都知道龟兔赛跑啦。但还是再解释一下快慢指针：这种算法的两个指针的在数组上（或是链表上，序列上）的移动速度不一样。还别说，这种方法在解决有环的链表和数组时特别有用。

## 单调栈
我们要始终保持栈顶元素是所访问过的元素中最小的，如果当前元素小于栈顶元素，就让栈顶元素出栈，让当前元素入栈。如果访问的元素大于栈顶元素，就要计算他和栈顶元素的差值，我们记录最大的即可。


# 数据结构
https://cloud.tencent.com/developer/article/1634155

1.数组(Array)

数组是一种聚合数据类型，它是将具有相同类型的若干变量有序地组织在一起的集合。数组可以说是最基本的数据结构，在各种编程语言中都有对应。一个数组可以分解为多个数组元素，按照数据元素的类型，数组可以分为整型数组、字符型数组、浮点型数组、指针数组和结构数组等。数组还可以有一维、二维以及多维等表现形式。

2.栈( Stack)

栈是一种特殊的线性表，它只能在一个表的一个固定端进行数据结点的插入和删除操作。栈按照后进先出的原则来存储数据，也就是说，先插入的数据将被压入栈底，最后插入的数据在栈顶，读出数据时，从栈顶开始逐个读出。栈在汇编语言程序中，经常用于重要数据的现场保护。栈中没有数据时，称为空栈。

3.队列(Queue)

队列和栈类似，也是一种特殊的线性表。和栈不同的是，队列只允许在表的一端进行插入操作，而在另一端进行删除操作。一般来说，进行插入操作的一端称为队尾，进行删除操作的一端称为队头。队列中没有元素时，称为空队列。

4.链表( Linked List)

链表是一种数据元素按照链式存储结构进行存储的数据结构，这种存储结构具有在物理上存在非连续的特点。链表由一系列数据结点构成，每个数据结点包括数据域和指针域两部分。其中，指针域保存了数据结构中下一个元素存放的地址。链表结构中数据元素的逻辑顺序是通过链表中的指针链接次序来实现的。

5.树( Tree)

树是典型的非线性结构，它是包括，2个结点的有穷集合K。在树结构中，有且仅有一个根结点，该结点没有前驱结点。在树结构中的其他结点都有且仅有一个前驱结点，而且可以有两个后继结点，m≥0。

6.图(Graph)

图是另一种非线性数据结构。在图结构中，数据结点一般称为顶点，而边是顶点的有序偶对。如果两个顶点之间存在一条边，那么就表示这两个顶点具有相邻关系。

7.堆(Heap)

堆是一种特殊的树形数据结构，一般讨论的堆都是二叉堆。堆的特点是根结点的值是所有结点中最小的或者最大的，并且根结点的两个子树也是一个堆结构。

8.散列表(Hash)

散列表源自于散列函数(Hash function)，其思想是如果在结构中存在关键字和T相等的记录，那么必定在F(T)的存储位置可以找到该记录，这样就可以不用进行比较操作而直接取得所查记录。


# ref
* https://kyonhuang.top/blog/greedy-algorithm/
* https://www.cvmart.net/community/detail/1951
* https://mirrors.gitcode.host/labuladong/fucking-algorithm/index.html
